--- Modules/socketmodule.c
+++ Modules/socketmodule.c
@@ -2420,6 +2420,7 @@ Returns the timeout in seconds (float) associated with socket \n\
 operations. A timeout of None indicates that timeouts on socket \n\
 operations are disabled.");
 
+#if defined(HAVE_SETSOCKOPT)
 /* s.setsockopt() method.
    With an integer third argument, sets an integer option.
    With a string third argument, sets an option from a buffer;
@@ -2458,6 +2459,7 @@ PyDoc_STRVAR(setsockopt_doc,
 \n\
 Set a socket option.  See the Unix manual for level and option.\n\
 The value argument can either be an integer or a string.");
+#endif /* defined(HAVE_SETSOCKOPT) */
 
 
 /* s.getsockopt() method.
@@ -2513,6 +2515,7 @@ If a nonzero buffersize argument is given, the return value is a\n\
 string of that length; otherwise it is an integer.");
 
 
+#if defined(HAVE_BIND)
 /* s.bind(sockaddr) method */
 
 static PyObject *
@@ -2539,6 +2542,7 @@ PyDoc_STRVAR(bind_doc,
 Bind the socket to a local address.  For IP sockets, the address is a\n\
 pair (host, port); the host must refer to the local host. For raw packet\n\
 sockets the address is a tuple (ifname, proto [,pkttype [,hatype]])");
+#endif /* defined(HAVE_BIND) */
 
 
 /* s.close() method.
@@ -2584,6 +2588,7 @@ Close the socket object without closing the underlying file descriptor.\n\
 The object cannot be used after this call, but the file descriptor\n\
 can be reused for other purposes.  The file descriptor is returned.");
 
+#if defined(HAVE_CONNECT)
 static int
 sock_connect_impl(PySocketSockObject *s, void* Py_UNUSED(data))
 {
@@ -2721,6 +2726,7 @@ PyDoc_STRVAR(connect_ex_doc,
 \n\
 This is like connect(address), but returns an error code (the errno value)\n\
 instead of raising an exception when an error occurs.");
+#endif /* defined(HAVE_CONNECT) */
 
 
 /* s.fileno() method */
@@ -3643,6 +3649,7 @@ until all data is sent.  If an error occurs, it's impossible\n\
 to tell how much data has been sent.");
 
 
+#if defined(MS_WINDOWS) || defined(HAVE_SENDTO)
 struct sock_sendto {
     char *buf;
     Py_ssize_t len;
@@ -3729,6 +3736,7 @@ PyDoc_STRVAR(sendto_doc,
 \n\
 Like send(data, flags) but allows specifying the destination address.\n\
 For IP sockets, the address is a pair (hostaddr, port).");
+#endif /* defined(MS_WINDOWS) || defined(HAVE_SENDTO) */
 
 
 /* The sendmsg() and recvmsg[_into]() methods require a working
@@ -4067,14 +4075,18 @@ socket.fromshare().");
 static PyMethodDef sock_methods[] = {
     {"_accept",           (PyCFunction)sock_accept, METH_NOARGS,
                       accept_doc},
+#if defined(HAVE_BIND)
     {"bind",              (PyCFunction)sock_bind, METH_O,
                       bind_doc},
+#endif
     {"close",             (PyCFunction)sock_close, METH_NOARGS,
                       close_doc},
+#if defined(HAVE_CONNECT)
     {"connect",           (PyCFunction)sock_connect, METH_O,
                       connect_doc},
     {"connect_ex",        (PyCFunction)sock_connect_ex, METH_O,
                       connect_ex_doc},
+#endif
     {"detach",            (PyCFunction)sock_detach, METH_NOARGS,
                       detach_doc},
     {"fileno",            (PyCFunction)sock_fileno, METH_NOARGS,
@@ -4109,16 +4121,20 @@ static PyMethodDef sock_methods[] = {
                       send_doc},
     {"sendall",           (PyCFunction)sock_sendall, METH_VARARGS,
                       sendall_doc},
+#if defined(MS_WINDOWS) || defined(HAVE_SENDTO)
     {"sendto",            (PyCFunction)sock_sendto, METH_VARARGS,
                       sendto_doc},
+#endif
     {"setblocking",       (PyCFunction)sock_setblocking, METH_O,
                       setblocking_doc},
     {"settimeout",    (PyCFunction)sock_settimeout, METH_O,
                       settimeout_doc},
     {"gettimeout",    (PyCFunction)sock_gettimeout, METH_NOARGS,
                       gettimeout_doc},
+#if defined(HAVE_SETSOCKOPT)
     {"setsockopt",        (PyCFunction)sock_setsockopt, METH_VARARGS,
                       setsockopt_doc},
+#endif
     {"shutdown",          (PyCFunction)sock_shutdown, METH_O,
                       shutdown_doc},
 #ifdef CMSG_LEN
@@ -4404,6 +4420,7 @@ static PyTypeObject sock_type = {
 };
 
 
+#if defined(MS_WINDOWS) || defined(HAVE_GETHOSTNAME)
 /* Python interface to gethostname(). */
 
 /*ARGSUSED*/
@@ -4463,6 +4480,7 @@ PyDoc_STRVAR(gethostname_doc,
 "gethostname() -> string\n\
 \n\
 Return the current host name.");
+#endif /* defined(MS_WINDOWS) || defined(HAVE_GETHOSTNAME) */
 
 #ifdef HAVE_SETHOSTNAME
 PyDoc_STRVAR(sethostname_doc,
@@ -4501,6 +4501,7 @@ extern int sethostname(const char *, size_t);
 }
 #endif
 
+#if defined(HAVE_GETHOSTBYNAME)
 /* Python interface to gethostbyname(name). */
 
 /*ARGSUSED*/
@@ -4526,8 +4526,10 @@ PyDoc_STRVAR(gethostbyname_doc,
 "gethostbyname(host) -> address\n\
 \n\
 Return the IP address (a string of the form '255.255.255.255') for a host.");
+#endif /* defined(HAVE_GETHOSTBYNAME) */
 
 
+#if defined(HAVE_GETHOSTBYNAME) || defined(HAVE_GETHOSTBYADDR)
 /* Convenience function common to gethostbyname_ex and gethostbyaddr */
 
 static PyObject *
@@ -4673,8 +4673,10 @@ gethost_common(struct hostent *h, struct sockaddr *addr, size_t alen, int af)
     Py_XDECREF(addr_list);
     return rtn_tuple;
 }
+#endif /* defined(HAVE_GETHOSTBYNAME) || defined(HAVE_GETHOSTBYADDR) */
 
 
+#if defined(HAVE_GETHOSTBYNAME)
 /* Python interface to gethostbyname_ex(name). */
 
 /*ARGSUSED*/
@@ -4743,8 +4745,10 @@ PyDoc_STRVAR(ghbn_ex_doc,
 \n\
 Return the true host name, a list of aliases, and a list of IP addresses,\n\
 for a host.  The host argument is a string giving a host name or IP number.");
+#endif /* defined(HAVE_GETHOSTBYNAME) */
 
 
+#if defined(HAVE_GETHOSTBYADDR)
 /* Python interface to gethostbyaddr(IP). */
 
 /*ARGSUSED*/
@@ -4835,6 +4839,7 @@ PyDoc_STRVAR(gethostbyaddr_doc,
 \n\
 Return the true host name, a list of aliases, and a list of IP addresses,\n\
 for a host.  The host argument is a string giving a host name or IP number.");
+#endif /* defined(HAVE_GETHOSTBYADDR) */
 
 
 /* Python interface to getservbyname(name).
@@ -5192,6 +5192,7 @@ PyDoc_STRVAR(htonl_doc,
 \n\
 Convert a 32-bit integer from host to network byte order.");
 
+#if defined(HAVE_INET_ATON) || defined(HAVE_INET_ADDR)
 /* socket.inet_aton() and socket.inet_ntoa() functions. */
 
 PyDoc_STRVAR(inet_aton_doc,
@@ -5264,7 +5265,9 @@ socket_inet_aton(PyObject *self, PyObject *args)
 
 #endif
 }
+#endif /* defined(HAVE_INET_ATON) || defined(HAVE_INET_ADDR) */
 
+#if defined(HAVE_INET_NTOA)
 PyDoc_STRVAR(inet_ntoa_doc,
 "inet_ntoa(packed_ip) -> ip_address_string\n\
 \n\
@@ -5292,6 +5295,7 @@ socket_inet_ntoa(PyObject *self, PyObject *args)
 
     return PyUnicode_FromString(inet_ntoa(packed_addr));
 }
+#endif /* defined(HAVE_INET_NTOA) */
 
 #if defined(HAVE_INET_PTON) || defined(MS_WINDOWS)
 
@@ -5915,14 +5915,20 @@ range of values.");
 /* List of functions exported by this module. */
 
 static PyMethodDef socket_methods[] = {
+#ifdef HAVE_GETHOSTBYNAME
     {"gethostbyname",           socket_gethostbyname,
      METH_VARARGS, gethostbyname_doc},
     {"gethostbyname_ex",        socket_gethostbyname_ex,
      METH_VARARGS, ghbn_ex_doc},
+#endif
+#ifdef GETHOSTBYADDR
     {"gethostbyaddr",           socket_gethostbyaddr,
      METH_VARARGS, gethostbyaddr_doc},
+#endif
+#if defined(MS_WINDOWS) || defined(HAVE_GETHOSTNAME)
     {"gethostname",             socket_gethostname,
      METH_NOARGS,  gethostname_doc},
+#endif
 #ifdef HAVE_SETHOSTNAME
     {"sethostname",             socket_sethostname,
      METH_VARARGS,  sethostname_doc},
@@ -5978,10 +5982,14 @@ static PyMethodDef socket_methods[] = {
      METH_VARARGS, htons_doc},
     {"htonl",                   socket_htonl,
      METH_O, htonl_doc},
+#if defined(HAVE_INET_ATON) || defined(HAVE_INET_ADDR)
     {"inet_aton",               socket_inet_aton,
      METH_VARARGS, inet_aton_doc},
+#endif
+#if defined(HAVE_INET_NTOA)
     {"inet_ntoa",               socket_inet_ntoa,
      METH_VARARGS, inet_ntoa_doc},
+#endif
 #if defined(HAVE_INET_PTON) || defined(MS_WINDOWS)
     {"inet_pton",               socket_inet_pton,
      METH_VARARGS, inet_pton_doc},
